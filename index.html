<![doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Top-down Survival â€” Arcade</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      :root {
        --bg: #0f1724;
        --accent: #ff6b6b;
        --accent2: #7c5cff;
        --hud: #ffffffcc;
        --muted: #ffffff66;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: linear-gradient(180deg, #071226 0%, #07112a 100%);
        -webkit-tap-highlight-color: transparent;
      }
      * {
        box-sizing: border-box;
        -webkit-user-select: none;
        user-select: none;
        -ms-touch-action: manipulation;
        touch-action: none;
      }
      /* 9:16 responsive container */
      .wrap {
        width: 100%;
        max-width: 400px;
        margin: 14px auto;
        position: relative;
      }
      .frame {
        position: relative;
        width: 100%;
        padding-top: 177.7778%;
        background: transparent;
        overflow: hidden;
        border-radius: 12px;
      }
      canvas {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      /* HUD overlay elements for accessible touch targets */
      .touch-layer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
      }
      .joystick,
      .skills {
        position: absolute;
        pointer-events: auto;
      }
      .joystick {
        left: 12px;
        bottom: 12px;
        width: 140px;
        height: 140px;
      }
      .skills {
        right: 12px;
        bottom: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 140px;
        align-items: flex-end;
      }
      .skill-btn {
        width: 56px;
        height: 56px;
        border-radius: 12px;
        background: linear-gradient(180deg, var(--accent2), #4f3bd6);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 700;
        font-size: 18px;
        pointer-events: auto;
        border: 3px solid rgba(255, 255, 255, 0.06);
        position: relative;
        overflow: hidden;
      }
      .skill-btn .cooler {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        pointer-events: none;
        mix-blend-mode: overlay;
        opacity: 0.95;
      }
      .skill-btn[disabled] {
        opacity: 0.45;
        pointer-events: none;
      }
      /* Level-up overlay */
      .overlay {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        background: rgba(2, 6, 23, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      }
      .choices {
        display: flex;
        gap: 12px;
        padding: 12px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.02));
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }
      .choice {
        width: 88px;
        height: 88px;
        background: #0f1724;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--hud);
        font-size: 12px;
        padding: 6px;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.04);
        cursor: pointer;
        min-width: 88px;
        min-height: 88px;
      }
      .choice:active {
        transform: scale(0.98);
      }
      .xpbar-wrap {
        position: absolute;
        left: 10%;
        right: 10%;
        bottom: 8px;
        height: 12px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        overflow: hidden;
      }
      .xpbar {
        height: 100%;
        background: linear-gradient(90deg, var(--accent), var(--accent2));
        width: 0%;
      }
      @media (max-width: 340px) {
        .joystick {
          width: 120px;
          height: 120px;
        }
        .skills {
          width: 120px;
        }
        .skill-btn {
          width: 52px;
          height: 52px;
        }
        .choice {
          width: 76px;
          height: 76px;
          min-width: 76px;
          min-height: 76px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap" id="gameWrap">
      <div class="frame">
        <canvas id="c"></canvas>
        <div class="touch-layer" id="touchLayer">
          <div class="joystick" id="joystick"></div>
          <div class="skills" id="skills">
            <div
              class="skill-btn"
              id="skill0"
              role="button"
              aria-label="skill1"
              style="background: linear-gradient(180deg, #ff9b9b, #ff6b6b)"
            >
              <div class="cooler"></div>
              A
            </div>
            <div
              class="skill-btn"
              id="skill1"
              role="button"
              aria-label="skill2"
              style="background: linear-gradient(180deg, #7c5cff, #5b3bff)"
            >
              <div class="cooler"></div>
              B
            </div>
            <div
              class="skill-btn"
              id="skill2"
              role="button"
              aria-label="skill3"
              style="background: linear-gradient(180deg, #35d0de, #1ca7ff)"
            >
              <div class="cooler"></div>
              C
            </div>
          </div>
        </div>
        <div class="xpbar-wrap"><div class="xpbar" id="xpbar"></div></div>
        <!-- Level-up overlay injected dynamically -->
      </div>
    </div>

    <script>
      /* Safe Farcade SDK wrapper to avoid startup crashes when SDK isn't available immediately */
      const FarcadeSafe = (function () {
        const has = !!(window.FarcadeSDK && window.FarcadeSDK.singlePlayer);
        return {
          ready() {
            try {
              if (has) window.FarcadeSDK.singlePlayer.actions.ready();
            } catch (e) {}
          },
          gameOver(obj) {
            try {
              if (has) window.FarcadeSDK.singlePlayer.actions.gameOver(obj);
            } catch (e) {}
          },
          haptic() {
            try {
              if (has) window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            } catch (e) {}
          },
          on(event, cb) {
            try {
              if (window.FarcadeSDK && window.FarcadeSDK.on) window.FarcadeSDK.on(event, cb);
            } catch (e) {}
          },
        };
      })();

      /* Minimal utilities */
      const $ = (s, root = document) => root.querySelector(s);
      const canvas = $("#c");
      const ctx = canvas.getContext("2d", { alpha: false });
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let SAFE_MARGIN = 24;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        DPR = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.round(rect.width * DPR);
        canvas.height = Math.round(rect.height * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        SAFE_MARGIN = Math.max(24, Math.min(rect.width, rect.height) * 0.03);
        game.onResize(rect.width, rect.height);
      }

      /* pixel sprite data */
      const SPRITES = {
        player: [
          [null, null, null, "#0b1220", "#0b1220", null, null, null],
          [null, null, "#0b1220", "#7b5a3a", "#7b5a3a", "#0b1220", null, null],
          [null, "#0b1220", "#ffd166", "#c75a2a", "#ffd166", "#ffd166", "#0b1220", null],
          [null, "#0b1220", "#ffd166", "#072a2f", "#072a2f", "#ffd166", "#0b1220", null],
          [null, null, "#0b1220", "#0b1220", "#0b1220", "#0b1220", null, null],
        ],
        goblin: [
          [null, null, "#16321a", "#16321a", null],
          [null, "#16321a", "#8bd35f", "#8bd35f", "#16321a"],
          ["#16321a", "#8bd35f", "#35d0de", "#8bd35f", "#16321a"],
          [null, "#16321a", "#8bd35f", "#8bd35f", "#16321a"],
          [null, null, "#16321a", "#16321a", null],
        ],
        slime: [
          [null, "#003b2f", "#003b2f", "#003b2f", null],
          ["#003b2f", "#35d0de", "#35d0de", "#35d0de", "#003b2f"],
          ["#003b2f", "#35d0de", "#7ff3e9", "#35d0de", "#003b2f"],
          [null, "#003b2f", "#35d0de", "#35d0de", null],
        ],
        bat: [
          [null, "#1b1020", "#af7fbf", "#1b1020", null],
          ["#1b1020", "#af7fbf", "#ff9ab0", "#af7fbf", "#1b1020"],
          [null, "#1b1020", "#af7fbf", "#1b1020", null],
        ],
      };

      /* normalize possible broken entries and ensure rectangular grids */
      function normalizeSprites() {
        Object.keys(SPRITES).forEach((k) => {
          const s = SPRITES[k];
          const w = Math.max(...s.map((r) => r.length));
          for (let r = 0; r < s.length; r++) {
            for (let c = 0; c < w; c++) {
              if (typeof s[r][c] === "undefined") s[r][c] = null;
            }
          }
        });
      }
      normalizeSprites();

      /* draw pixel sprite centered at cx,cy with desired width (in canvas px) */
      function drawPixelSprite(sprite, cx, cy, desiredW, outline) {
        const h = sprite.length;
        const w = sprite[0].length;
        const scale = desiredW / w;
        const sx = Math.floor(-desiredW / 2);
        const sy = Math.floor(-(h * scale) / 2);
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            const col = sprite[r][c];
            if (!col) continue;
            ctx.fillStyle = col;
            ctx.fillRect(cx + sx + c * scale, cy + sy + r * scale, Math.ceil(scale), Math.ceil(scale));
            if (outline) {
              ctx.strokeStyle = "rgba(0,0,0,0.25)";
              ctx.strokeRect(cx + sx + c * scale, cy + sy + r * scale, Math.ceil(scale), Math.ceil(scale));
            }
          }
        }
      }

      /* Game state and entities */
      const game = {
        worldW: 1920,
        worldH: 1080,
        viewW: 300,
        viewH: 533,
        running: false,
        last: 0,
        dt: 0,
        enemies: [],
        explosions: [],
        bullets: [],
        pickups: [],
        decorations: { trees: [], flowers: [], insects: [] },
        damageTexts: [],
        score: 0,
        level: 1,
        xp: 0,
        xpToNext: 20,
        hp: 100,
        maxHp: 100,
        spawnTimer: 0,
        spawnRate: 1.2,
        timeElapsed: 0,
        skillSlots: [null, null, null],
        skillCooldowns: [0, 0, 0],
        paused: false,
        muted: false,
        joystickVec: { x: 0, y: 0 },
        lastHitTime: 0,
        playLoopReq: null,
        shootTimer: 0,
        cameraX: 0,
        cameraY: 0,
        _extraEnemyUpgrades: 0, // +1 enemy per upgrade (max applied in spawn)
        onResize(w, h) {
          this.viewW = w;
          this.viewH = h;
          this.cameraX = clamp(this.cameraX, 0, Math.max(0, this.worldW - this.viewW));
          this.cameraY = clamp(this.cameraY, 0, Math.max(0, this.worldH - this.viewH));
          clampPlayer();
        },
        reset() {
          this.enemies.length = 0;
          this.explosions.length = 0;
          this.bullets.length = 0;
          this.pickups.length = 0;
          this.score = 0;
          this.level = 1;
          this.xp = 0;
          this.xpToNext = 20;
          this.hp = this.maxHp = 100;
          this.spawnTimer = 0;
          this.spawnRate = 1.2;
          this.timeElapsed = 0;
          this.skillSlots = [null, null, null];
          this.skillCooldowns = [0, 0, 0];
          this.paused = false;
          this.running = true;
          this._extraEnemyUpgrades = 0;
          player.x = this.worldW * 0.5;
          player.y = this.worldH * 0.7;
          player.speed = 160;
          player.dir = { x: 0, y: -1 };
          this.shootTimer = 0;
          lastFrame = performance.now();
          if (this.playLoopReq) cancelAnimationFrame(this.playLoopReq);
          this.playLoopReq = requestAnimationFrame(loop);
          this.decorations.trees = [];
          this.decorations.flowers = [];
          this.decorations.insects = [];
          generateDecorations();
        },
      };

      /* Player */
      const player = {
        x: 960,
        y: 756,
        r: 18,
        speed: 160,
        dir: { x: 0, y: -1 },
        color: "#ffd166",
        invuln: 0,
        _regen: 0,
        _xpBoost: 0,
        _dmg: 0,
        _multishot: 0,
        shootingAnim: 0,
        walkAnim: 0,
      };

      function clampPlayer() {
        player.x = Math.min(Math.max(player.x, SAFE_MARGIN + player.r), game.worldW - SAFE_MARGIN - player.r);
        player.y = Math.min(Math.max(player.y, SAFE_MARGIN + player.r), game.worldH - SAFE_MARGIN - player.r);
      }

      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      /* Input: joystick implementation */
      const joystickEl = $("#joystick");
      let joyState = { active: false, origin: { x: 0, y: 0 }, pos: { x: 0, y: 0 } };
      function setupJoystick() {
        const jcan = document.createElement("canvas");
        function sizeCanvas() {
          jcan.width = joystickEl.clientWidth * DPR;
          jcan.height = joystickEl.clientHeight * DPR;
          jcan.style.width = "100%";
          jcan.style.height = "100%";
        }
        sizeCanvas();
        joystickEl.appendChild(jcan);
        const jctx = jcan.getContext("2d");
        function drawJoy() {
          const w = jcan.width,
            h = jcan.height;
          const cx = w / 2,
            cy = h / 2;
          jctx.clearRect(0, 0, w, h);
          jctx.save();
          jctx.scale(DPR, DPR);
          jctx.fillStyle = "rgba(255,255,255,0.04)";
          jctx.beginPath();
          jctx.arc(cx / DPR, cy / DPR, Math.min(jcan.clientWidth, jcan.clientHeight) / 2.2, 0, Math.PI * 2);
          jctx.fill();
          jctx.fillStyle = "rgba(255,255,255,0.08)";
          const px = cx / DPR + (joyState.pos.x - joyState.origin.x);
          const py = cy / DPR + (joyState.pos.y - joyState.origin.y);
          jctx.beginPath();
          jctx.arc(px, py, Math.min(jcan.clientWidth, jcan.clientHeight) / 6, 0, Math.PI * 2);
          jctx.fill();
          jctx.restore();
          requestAnimationFrame(drawJoy);
        }
        drawJoy();

        function toLocal(e, el) {
          const r = el.getBoundingClientRect();
          if (e.touches) e = e.touches[0];
          return { x: e.clientX - r.left, y: e.clientY - r.top };
        }

        function start(e) {
          e.preventDefault();
          joyState.active = true;
          const p = toLocal(e, joystickEl);
          joyState.origin = { x: p.x, y: p.y };
          joyState.pos = { x: p.x, y: p.y };
        }
        function move(e) {
          if (!joyState.active) return;
          const p = toLocal(e, joystickEl);
          joyState.pos = { x: p.x, y: p.y };
          const dx = joyState.pos.x - joyState.origin.x;
          const dy = joyState.pos.y - joyState.origin.y;
          const max = joystickEl.clientWidth * 0.35;
          const mag = Math.hypot(dx, dy);
          const nx = mag > 1 ? dx / Math.max(1, mag) : 0;
          const ny = mag > 1 ? dy / Math.max(1, mag) : 0;
          const len = Math.min(max, mag) / max;
          game.joystickVec.x = nx * len;
          game.joystickVec.y = ny * len;
        }
        function end(e) {
          joyState.active = false;
          game.joystickVec.x = 0;
          game.joystickVec.y = 0;
        }

        joystickEl.addEventListener("touchstart", start, { passive: false });
        joystickEl.addEventListener("touchmove", move, { passive: false });
        joystickEl.addEventListener("touchend", end);
        joystickEl.addEventListener("mousedown", (e) => {
          start(e);
          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", () => {
            end();
            window.removeEventListener("mousemove", move);
          });
        });
        const obs = new ResizeObserver(() => {
          sizeCanvas();
        });
        obs.observe(joystickEl);
      }

      /* Keyboard / mouse fallback */
      const keys = {};
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      /* Enemy spawn - spawns more & tougher enemies as level increases */
      function spawnEnemy(count = 1) {
        const types = ["goblin", "slime", "bat"];
        for (let n = 0; n < count; n++) {
          const side = Math.floor(Math.random() * 4); // 0:left,1:right,2:top,3:bottom
          let x, y;
          const pad = SAFE_MARGIN;
          if (side === 0) {
            x = -40;
            y = pad + Math.random() * (game.worldH - pad * 2);
          } else if (side === 1) {
            x = game.worldW + 40;
            y = pad + Math.random() * (game.worldH - pad * 2);
          } else if (side === 2) {
            x = pad + Math.random() * (game.worldW - pad * 2);
            y = -40;
          } else {
            x = pad + Math.random() * (game.worldW - pad * 2);
            y = game.worldH + 40;
          }
          const t = types[Math.floor(Math.random() * types.length)];
          const baseSpeed = 40 + game.level * 6 + Math.random() * 30 + game.timeElapsed * 0.5;
          const hp = 12 + Math.floor(Math.random() * 22) + game.level * 6;
          const size = 12 + Math.random() * 20;
          game.enemies.push({
            x,
            y,
            type: t,
            speed: baseSpeed,
            hp: hp,
            maxHp: hp,
            r: size,
            spriteKey: t,
          });
        }
      }

      /* Simple collision helpers */
      function dist(a, b) {
        const dx = a.x - b.x,
          dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }
      function circleHit(ax, ay, ar, bx, by, br) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by) <= (ar + br) * (ar + br);
      }

      /* Explosions: for active skill effects */
      function createExplosion(x, y, rad, dmg, life = 0.4) {
        game.explosions.push({ x, y, r: rad, dmg, life, ttl: life });
      }

      /* Skills system - multishot passive included */
      const ALL_SKILLS = {
        dash_active: {
          name: "Dash",
          desc: "Dash forward, damaging enemies.",
          type: "active",
          cooldown: 4,
          activate(ctx) {
            const dir = normalize(game.joystickVec.x, game.joystickVec.y);
            const dx = dir.x || player.dir.x,
              dy = dir.y || player.dir.y;
            player.x += dx * 80;
            player.y += dy * 80;
            clampPlayer();
            createExplosion(player.x, player.y, 36, 40, 0.12);
            FarcadeSafe.haptic();
          },
        },
        blast_active: {
          name: "Blast",
          desc: "Create area blast around you.",
          type: "active",
          cooldown: 6,
          activate(ctx) {
            createExplosion(player.x, player.y, 80, 999, 0.18);
            FarcadeSafe.haptic();
          },
        },
        shield_active: {
          name: "Shield",
          desc: "Temporary invulnerable.",
          type: "active",
          cooldown: 10,
          activate(ctx) {
            player.invuln = 1.2;
            FarcadeSafe.haptic();
          },
        },
        hp_plus_passive: {
          name: "+Max HP",
          desc: "Increase max HP by 20",
          type: "passive",
          apply(ctx) {
            game.maxHp += 20;
            game.hp += 20;
          },
        },
        regen_passive: {
          name: "Regen",
          desc: "Gain +1 HP/sec",
          type: "passive",
          apply(ctx) {
            player._regen = (player._regen || 0) + 1;
          },
        },
        xp_plus_passive: {
          name: "XP Boost",
          desc: "+25% XP gain",
          type: "passive",
          apply(ctx) {
            player._xpBoost = (player._xpBoost || 0) + 0.25;
          },
        },
        damage_passive: {
          name: "Damage+",
          desc: "Active skills +25% damage",
          type: "passive",
          apply(ctx) {
            player._dmg = (player._dmg || 0) + 0.25;
          },
        },
        multishot_passive: {
          name: "MultiShot",
          desc: "Shoot multiple targets at once.",
          type: "passive",
          apply(ctx) {
            player._multishot = (player._multishot || 0) + 1;
          },
        },
      };

      function chooseSkillOptions() {
        const keys = Object.keys(ALL_SKILLS);
        const pick = [];
        while (pick.length < 3 && keys.length) {
          const idx = Math.floor(Math.random() * keys.length);
          const k = keys.splice(idx, 1)[0];
          pick.push(k);
        }
        return pick;
      }

      /* Level up handling */
      function checkLevelUp() {
        if (game.xp >= game.xpToNext) {
          game.xp -= game.xpToNext;
          game.level += 1;
          game.xpToNext = Math.floor(game.xpToNext * 1.35 + game.level * 5);
          game.paused = true;
          FarcadeSafe.haptic();
          showLevelUpOverlay();
        }
      }

      /* Level-up overlay DOM */
      function showLevelUpOverlay() {
        const wrap = document.createElement("div");
        wrap.className = "overlay";
        wrap.id = "lvlup";
        const choicesWrap = document.createElement("div");
        choicesWrap.className = "choices";
        const opts = chooseSkillOptions();
        opts.forEach((k, idx) => {
          const info = ALL_SKILLS[k];
          const c = document.createElement("div");
          c.className = "choice";
          c.tabIndex = 0;
          c.style.minWidth = "88px";
          c.style.minHeight = "88px";
          c.innerHTML = `<div style="font-weight:700">${info.name}</div><small style="opacity:.8">${info.type === "active" ? "Active" : "Passive"}</small>`;
          c.addEventListener("click", () => {
            // apply passive or assign active
            if (info.type === "passive") {
              info.apply && info.apply();
            } else {
              const slot = game.skillSlots.findIndex((s) => s === null);
              const useSlot = slot >= 0 ? slot : 0;
              game.skillSlots[useSlot] = k;
              game.skillCooldowns[useSlot] = 0;
              updateSkillButtons();
            }
            // increment enemy count upgrade as requested (+1 enemy per upgrade, max at 10)
            game._extraEnemyUpgrades = Math.min(9, (game._extraEnemyUpgrades || 0) + 1);
            document.getElementById("lvlup")?.remove();
            game.paused = false;
          });
          choicesWrap.appendChild(c);
        });
        wrap.appendChild(choicesWrap);
        document.querySelector(".frame").appendChild(wrap);
      }

      /* Skill buttons wiring */
      function updateSkillButtons() {
        for (let i = 0; i < 3; i++) {
          const btn = $(`#skill${i}`);
          const key = game.skillSlots[i];
          const coolDiv = btn.querySelector(".cooler");
          if (!key) {
            btn.textContent = "";
            btn.style.opacity = 0.6;
            btn.setAttribute("disabled", "true");
            if (coolDiv) coolDiv.style.background = "transparent";
          } else {
            btn.textContent = ALL_SKILLS[key].name.split(" ")[0].slice(0, 2).toUpperCase();
            btn.style.opacity = 1;
            btn.removeAttribute("disabled");
            if (coolDiv) {
              const cd = game.skillCooldowns[i] || 0;
              const total = ALL_SKILLS[key].cooldown || 4;
              const pct = Math.max(0, Math.min(1, cd / total));
              // draw static initial (will be updated while running)
              coolDiv.style.background = `conic-gradient(rgba(0,0,0,0.45) ${pct * 360}deg, transparent 0deg)`;
            }
          }
        }
      }
      function useSkill(i) {
        const key = game.skillSlots[i];
        if (!key) return;
        const skill = ALL_SKILLS[key];
        if (!skill) return;
        const cd = skill.cooldown || 0;
        if (game.skillCooldowns[i] > 0) return;
        if (skill.type === "active") {
          skill.activate();
          const base = skill.cooldown || 4;
          game.skillCooldowns[i] = base;
        }
      }

      /* Bullets system: now target enemies; firing rate 0.3s; multi-shot support */
      function fireBulletTowardsTarget(x, y, targetX, targetY, dmg = 12) {
        const nx = targetX - x;
        const ny = targetY - y;
        const m = Math.hypot(nx, ny) || 1;
        const speed = 420;
        game.bullets.push({
          x,
          y,
          vx: (nx / m) * speed,
          vy: (ny / m) * speed,
          r: 4,
          dmg,
          ttl: 3.0,
        });
        player.shootingAnim = 0.18; // trigger shooting animation for bow/arrow
        FarcadeSafe.haptic();
      }

      /* Update loop */
      let lastFrame = performance.now();
      function loop(ts) {
        game.playLoopReq = requestAnimationFrame(loop);
        const now = ts;
        let dt = Math.min(0.06, (now - lastFrame) / 1000);
        lastFrame = now;
        if (!game.running) return;
        if (game.paused) {
          render();
          return;
        }
        // input / movement
        const kbX = (keys["arrowright"] || keys["d"] ? 1 : 0) - (keys["arrowleft"] || keys["a"] ? 1 : 0);
        const kbY = (keys["arrowdown"] || keys["s"] ? 1 : 0) - (keys["arrowup"] || keys["w"] ? 1 : 0);
        let ix = game.joystickVec.x || kbX;
        let iy = game.joystickVec.y || kbY;
        const moving = ix !== 0 || iy !== 0;
        if (moving) {
          const n = normalize(ix, iy);
          player.x += n.x * player.speed * dt;
          player.y += n.y * player.speed * dt;
          player.dir = { x: n.x, y: n.y };
          player.walkAnim = (player.walkAnim || 0) + dt * 14;
        } else {
          player.walkAnim = Math.max(0, (player.walkAnim || 0) - dt * 8);
        }
        clampPlayer();

        // update camera to follow player
        game.cameraX = clamp(player.x - game.viewW / 2, 0, Math.max(0, game.worldW - game.viewW));
        game.cameraY = clamp(player.y - game.viewH / 2, 0, Math.max(0, game.worldH - game.viewH));

        // regen passive
        if (player._regen) {
          game.hp = Math.min(game.maxHp, game.hp + player._regen * dt);
        }

        // shooting: auto-fire for nearby enemies (as requested only when close)
        game.shootTimer -= dt;
        const fireRate = 0.3;
        const autoShootRange = 180;
        if (game.shootTimer <= 0) {
          const enemiesInRange = game.enemies
            .map((e) => ({ e, d: Math.hypot(e.x - player.x, e.y - player.y) }))
            .filter((o) => o.d <= autoShootRange)
            .sort((a, b) => a.d - b.d);
          if (enemiesInRange.length > 0) {
            game.shootTimer = fireRate;
            const shots = 1 + (player._multishot || 0);
            const targets = enemiesInRange.slice(0, shots);
            const baseDmg = Math.round(12 * (1 + (player._dmg || 0)));
            for (const t of targets) {
              const dir = normalize(t.e.x - player.x, t.e.y - player.y);
              const bx = player.x + dir.x * (player.r + 6);
              const by = player.y + dir.y * (player.r + 6);
              fireBulletTowardsTarget(bx, by, t.e.x, t.e.y, baseDmg);
            }
          }
        }

        // spawn logic: higher levels spawn more frequently and in larger numbers
        game.spawnTimer -= dt;
        if (game.spawnTimer <= 0) {
          // spawn more enemies at higher levels (clamped), include +1 per upgrade (max 10)
          const baseSpawn = 1 + Math.floor(game.level / 4);
          const spawnAmount = Math.min(10, baseSpawn + (game._extraEnemyUpgrades || 0));
          spawnEnemy(spawnAmount);
          game.spawnTimer = Math.max(0.18, game.spawnRate - Math.min(1.2, game.level * 0.06));
        }
        game.timeElapsed += dt;
        if (game.timeElapsed > 8 && Math.random() < dt * 0.4) {
          const extra = 1 + Math.floor(game.level / 6);
          spawnEnemy(Math.min(4, extra));
        }

        // update bullets
        for (let i = game.bullets.length - 1; i >= 0; i--) {
          const b = game.bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.ttl -= dt;
          for (let j = game.enemies.length - 1; j >= 0; j--) {
            const e = game.enemies[j];
            if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r)) {
              e.hp -= b.dmg;
              // create damage text
              game.damageTexts.push({ x: e.x, y: e.y - e.r - 6, val: b.dmg, ttl: 0.7, vy: -18 });
              b.ttl = -1;
              createExplosion(b.x, b.y, 10, 0, 0.08);
              break;
            }
          }
          if (b.ttl <= 0 || b.x < -100 || b.x > game.worldW + 100 || b.y < -100 || b.y > game.worldH + 100) {
            game.bullets.splice(i, 1);
          }
        }

        // update enemies
        for (let i = game.enemies.length - 1; i >= 0; i--) {
          const e = game.enemies[i];
          const dx = player.x - e.x,
            dy = player.y - e.y;
          const mag = Math.hypot(dx, dy) || 1;
          e.x += (dx / mag) * e.speed * dt;
          e.y += (dy / mag) * e.speed * dt;
          // collision with explosions
          for (let j = game.explosions.length - 1; j >= 0; j--) {
            const ex = game.explosions[j];
            if (circleHit(e.x, e.y, e.r, ex.x, ex.y, ex.r)) {
              const dmg = ex.dmg * (player._dmg ? 1 + player._dmg : 1);
              e.hp -= dmg * dt * 10;
              game.damageTexts.push({ x: e.x, y: e.y - e.r - 6, val: Math.round(dmg * dt * 10), ttl: 0.7, vy: -18 });
            }
          }
          // contact with player
          if (circleHit(e.x, e.y, e.r, player.x, player.y, player.r + (player.invuln ? 4 : 0))) {
            if (!player.invuln && now / 1000 - game.lastHitTime > 0.5) {
              game.hp -= Math.max(4, 8 + Math.random() * 6);
              game.lastHitTime = now / 1000;
              FarcadeSafe.haptic();
            }
            e.hp = -1;
          }
          if (e.hp <= 0) {
            game.score += Math.floor(5 + Math.random() * 8 + game.level * 2);
            let xpGain = 4 + Math.floor(Math.random() * 6) + Math.floor(game.level * 0.5);
            if (player._xpBoost) xpGain = Math.floor(xpGain * (1 + player._xpBoost));
            game.pickups.push({
              x: e.x,
              y: e.y,
              amt: xpGain,
              ttl: 12,
            });
            game.enemies.splice(i, 1);
            FarcadeSafe.haptic();
          }
        }

        // update explosions
        for (let i = game.explosions.length - 1; i >= 0; i--) {
          const ex = game.explosions[i];
          ex.ttl -= dt;
          if (ex.ttl <= 0) game.explosions.splice(i, 1);
        }

        // pickups - magnet effect and collect
        for (let i = game.pickups.length - 1; i >= 0; i--) {
          const p = game.pickups[i];
          p.ttl -= dt;
          const dx = player.x - p.x;
          const dy = player.y - p.y;
          const d = Math.hypot(dx, dy);
          // magnet: if within radius, move toward player
          const magnetRange = 120;
          if (d < magnetRange) {
            const pull = (1 - d / magnetRange) * 320; // speed toward player
            p.x += (dx / (d || 1)) * pull * dt;
            p.y += (dy / (d || 1)) * pull * dt;
          } else {
            // slight float
            p.y += Math.sin((game.timeElapsed + i) * 2) * 0.3;
          }
          if (circleHit(p.x, p.y, 8, player.x, player.y, player.r)) {
            game.xp += p.amt;
            FarcadeSafe.haptic();
            game.pickups.splice(i, 1);
            continue;
          }
          if (p.ttl <= 0) {
            game.pickups.splice(i, 1);
          }
        }

        // insects (decor) movement
        for (const ins of game.decorations.insects) {
          ins.x += ins.vx * dt;
          ins.y += ins.vy * dt;
          if (ins.x < 0) ins.x = game.worldW;
          if (ins.x > game.worldW) ins.x = 0;
          if (ins.y < 0) ins.y = game.worldH;
          if (ins.y > game.worldH) ins.y = 0;
        }

        // cooldowns
        for (let i = 0; i < 3; i++) {
          if (game.skillCooldowns[i] > 0) {
            game.skillCooldowns[i] = Math.max(0, game.skillCooldowns[i] - dt);
            // update DOM cooler for instant feedback
            const btn = $(`#skill${i}`);
            const key = game.skillSlots[i];
            const coolDiv = btn?.querySelector(".cooler");
            if (coolDiv && key) {
              const total = ALL_SKILLS[key].cooldown || 4;
              const pct = Math.max(0, Math.min(1, game.skillCooldowns[i] / total));
              coolDiv.style.background = `conic-gradient(rgba(0,0,0,0.55) ${pct * 360}deg, transparent 0deg)`;
            }
          } else {
            const btn = $(`#skill${i}`);
            const coolDiv = btn?.querySelector(".cooler");
            if (coolDiv) coolDiv.style.background = "transparent";
          }
        }

        // damage text update
        for (let i = game.damageTexts.length - 1; i >= 0; i--) {
          const dtxt = game.damageTexts[i];
          dtxt.ttl -= dt;
          dtxt.y += dtxt.vy * dt;
          dtxt.vy += 40 * dt; // gravity downwards for nicer motion
          if (dtxt.ttl <= 0) game.damageTexts.splice(i, 1);
        }

        // invuln timer
        if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);

        // score by survival
        game.score += dt * 0.3;

        checkLevelUp();

        // check death
        if (game.hp <= 0) {
          game.running = false;
          FarcadeSafe.haptic();
          FarcadeSafe.gameOver({ score: Math.floor(game.score) });
          return;
        }

        // reduce shooting anim
        player.shootingAnim = Math.max(0, (player.shootingAnim || 0) - dt);

        render();
      }

      /* Rendering */
      function render() {
        const vw = game.viewW,
          vh = game.viewH;
        ctx.fillStyle = "#1e6b2a";
        ctx.fillRect(0, 0, vw, vh);

        const camX = game.cameraX;
        const camY = game.cameraY;

        // grassy tiled look
        const tileSize = 64;
        for (let gx = Math.floor(camX / tileSize) * tileSize; gx < camX + vw + tileSize; gx += tileSize) {
          for (let gy = Math.floor(camY / tileSize) * tileSize; gy < camY + vh + tileSize; gy += tileSize) {
            const sx = gx - camX;
            const sy = gy - camY;
            ctx.fillStyle = ((gx + gy) >> 6) & 1 ? "#2a7a34" : "#1e6b2a";
            ctx.fillRect(sx, sy, tileSize, tileSize);
            ctx.fillStyle = "rgba(255,255,255,0.02)";
            ctx.fillRect(sx + 4, sy + 2, 2, 8);
          }
        }

        // decorations: trees
        for (const t of game.decorations.trees) {
          const sx = t.x - camX;
          const sy = t.y - camY;
          if (sx < -80 || sx > vw + 80 || sy < -120 || sy > vh + 80) continue;
          ctx.fillStyle = "#6b4426";
          ctx.fillRect(sx - 6, sy, 12, 24);
          ctx.fillStyle = "#1a5a2a";
          ctx.beginPath();
          ctx.arc(sx, sy - 6, 28, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#2a7a34";
          ctx.beginPath();
          ctx.arc(sx - 12, sy - 2, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(sx + 12, sy - 2, 18, 0, Math.PI * 2);
          ctx.fill();
        }

        // flowers
        for (const f of game.decorations.flowers) {
          const sx = f.x - camX;
          const sy = f.y - camY;
          if (sx < -20 || sx > vw + 20 || sy < -20 || sy > vh + 20) continue;
          ctx.fillStyle = f.col;
          ctx.beginPath();
          ctx.arc(sx, sy, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "rgba(0,0,0,0.12)";
          ctx.fillRect(sx - 1, sy + 3, 2, 4);
        }

        // insects
        for (const ins of game.decorations.insects) {
          const sx = ins.x - camX;
          const sy = ins.y - camY;
          if (sx < -6 || sx > vw + 6 || sy < -6 || sy > vh + 6) continue;
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.beginPath();
          ctx.arc(sx + 1, sy + 1, 2.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = ins.col;
          ctx.beginPath();
          ctx.arc(sx, sy, 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // explosions
        for (const ex of game.explosions) {
          const sx = ex.x - camX;
          const sy = ex.y - camY;
          const t = Math.max(0, ex.ttl / ex.life);
          ctx.fillStyle = `rgba(255,120,80,${0.12 + 0.28 * t})`;
          ctx.beginPath();
          ctx.arc(sx, sy, ex.r * (1 + (1 - t) * 0.8), 0, Math.PI * 2);
          ctx.fill();
        }

        // bullets
        for (const b of game.bullets) {
          const sx = b.x - camX;
          const sy = b.y - camY;
          if (sx < -20 || sx > vw + 20 || sy < -20 || sy > vh + 20) continue;
          ctx.save();
          ctx.translate(sx, sy);
          ctx.fillStyle = "rgba(255,240,180,0.98)";
          ctx.beginPath();
          ctx.ellipse(0, 0, b.r, b.r * 0.8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // pickups (xp) - blue glow, no numbers displayed
        for (const p of game.pickups) {
          const sx = p.x - camX;
          const sy = p.y - camY;
          if (sx < -40 || sx > vw + 40 || sy < -40 || sy > vh + 40) continue;
          const wob = Math.sin((game.timeElapsed + p.x + p.y) * 6) * 2;
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.shadowBlur = 18;
          ctx.shadowColor = "rgba(80,200,255,0.9)";
          const grad = ctx.createRadialGradient(sx, sy + wob, 2, sx, sy + wob, 16);
          grad.addColorStop(0, "rgba(140,230,255,0.95)");
          grad.addColorStop(0.4, "rgba(60,190,255,0.6)");
          grad.addColorStop(1, "rgba(30,120,180,0.12)");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(sx, sy + wob, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = "#7ff3e9";
          ctx.beginPath();
          ctx.arc(sx, sy + wob, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.12)";
          ctx.beginPath();
          ctx.arc(sx, sy + wob, 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // enemies (pixel sprites)
        for (const e of game.enemies) {
          const sx = e.x - camX;
          const sy = e.y - camY;
          const key = e.spriteKey || e.type;
          const sprite = SPRITES[key] || SPRITES.goblin;
          const desiredW = Math.max(18, e.r * 1.8);
          drawPixelSprite(sprite, sx, sy, desiredW, true);
          // hp bar
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(sx - e.r, sy - e.r - 8, e.r * 2, 4);
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.fillRect(sx - e.r, sy - e.r - 8, (e.hp / e.maxHp) * e.r * 2, 4);
        }

        // player (pixel base)
        const psx = player.x - camX;
        const psy = player.y - camY;
        drawPixelSprite(SPRITES.player, psx, psy, player.r * 3.2, true);

        // overlay: draw bow/arm and legs (walking) and arrow when shooting
        drawPlayerExtras(psx, psy);

        // damage text render
        ctx.textAlign = "center";
        ctx.font = "12px system-ui";
        for (const dtxt of game.damageTexts) {
          const sx = dtxt.x - camX;
          const sy = dtxt.y - camY;
          ctx.fillStyle = "rgba(255,240,220,0.98)";
          ctx.fillText(dtxt.val, sx, sy);
        }

        // HUD top-left: Score / Level / HP
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = "left";
        const pad = SAFE_MARGIN;
        ctx.fillText(`Score: ${Math.floor(game.score)}`, pad, pad + 12);
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillText(`Level: ${game.level}`, pad, pad + 32);
        // HP bar
        const hpW = 120;
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.fillRect(pad, pad + 42, hpW, 10);
        ctx.fillStyle = "#ff6b6b";
        ctx.fillRect(pad, pad + 42, hpW * (Math.max(0, game.hp) / game.maxHp), 10);
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.strokeRect(pad, pad + 42, hpW, 10);

        ctx.fillStyle = "rgba(255,255,255,0.6)";
        ctx.font = "11px system-ui, sans-serif";
        ctx.fillText(`HP: ${Math.floor(game.hp)}/${game.maxHp}`, pad + hpW + 8, pad + 51);

        // skill cooldown overlays on buttons (screen-space arcs) - keep for clarity
        renderSkillCooldowns();
      }

      /* draw player extra details: bow, arrow, legs */
      function drawPlayerExtras(cx, cy) {
        // legs walking animation (two small arcs/rects)
        const walk = Math.sin(player.walkAnim || 0) * 1.6;
        ctx.save();
        ctx.translate(cx, cy);
        // legs
        ctx.fillStyle = "#0b1220";
        ctx.beginPath();
        ctx.ellipse(-6, 10 + walk, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6, 10 - walk, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        // bow and arm
        const dir = normalize(player.dir.x || 0, player.dir.y || -1);
        // compute angle for bow
        const ang = Math.atan2(dir.y, dir.x);
        ctx.translate(0, -2); // raise bow a bit
        ctx.rotate(ang);
        // bow body
        ctx.strokeStyle = "#3a2a1f";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(6, 0, 10, -Math.PI / 2, Math.PI / 2);
        ctx.stroke();
        // string
        ctx.strokeStyle = "#cfcfcf";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-4, -9);
        ctx.lineTo(-4, 9);
        ctx.stroke();
        // arm (back)
        ctx.fillStyle = "#ffd166";
        ctx.fillRect(-10, -6, 6, 6);
        // arrow: draw when shootingAnim > 0 slightly pulled
        const pull = player.shootingAnim > 0 ? 6 * (player.shootingAnim / 0.18) : 0;
        ctx.strokeStyle = "#6b3b1f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12 - pull, 0);
        ctx.lineTo(12, 0);
        ctx.stroke();
        // arrow head
        ctx.fillStyle = "#111827";
        ctx.beginPath();
        ctx.moveTo(12, 0);
        ctx.lineTo(8, -3);
        ctx.lineTo(8, 3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      /* Normalization helper */
      function normalize(x, y) {
        const m = Math.hypot(x, y) || 1;
        return { x: x / m, y: y / m };
      }

      /* Skill cooldown UI render: draw arcs on buttons */
      function renderSkillCooldowns() {
        for (let i = 0; i < 3; i++) {
          const btn = $(`#skill${i}`);
          if (!btn) continue;
          const rect = btn.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          const cx = rect.left + rect.width / 2 - canvasRect.left;
          const cy = rect.top + rect.height / 2 - canvasRect.top;
          const radius = Math.max(20, Math.min(30, rect.width * 0.42));
          const cd = game.skillCooldowns[i];
          if (cd > 0) {
            const total = ALL_SKILLS[game.skillSlots[i]]?.cooldown || 4;
            const pct = Math.max(0, Math.min(1, cd / total));
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,0.45)";
            ctx.lineWidth = 4;
            ctx.arc(cx, cy, radius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - pct));
            ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.font = "11px system-ui";
            ctx.textAlign = "center";
            ctx.fillText(Math.ceil(cd), cx, cy + 4);
          }
        }
      }

      /* Wire skill buttons events */
      function setupSkillButtons() {
        for (let i = 0; i < 3; i++) {
          const el = $(`#skill${i}`);
          el.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              useSkill(i);
            },
            { passive: false },
          );
          el.addEventListener("mousedown", (e) => {
            e.preventDefault();
            useSkill(i);
          });
        }
      }

      /* Hook Farcade SDK events */
      FarcadeSafe.on &&
        FarcadeSafe.on("play_again", () => {
          document.getElementById("lvlup")?.remove();
          game.reset();
        });
      FarcadeSafe.on &&
        FarcadeSafe.on("toggle_mute", ({ isMuted }) => {
          game.muted = !!isMuted;
        });

      /* Decorations generation */
      function generateDecorations() {
        for (let i = 0; i < 40; i++) {
          game.decorations.trees.push({
            x: Math.random() * game.worldW,
            y: Math.random() * game.worldH * 0.9 + game.worldH * 0.05,
          });
        }
        const cols = ["#ff7ac9", "#ffd166", "#8bd35f", "#ff9a3c"];
        for (let i = 0; i < 220; i++) {
          game.decorations.flowers.push({
            x: Math.random() * game.worldW,
            y: Math.random() * game.worldH,
            col: cols[Math.floor(Math.random() * cols.length)],
          });
        }
        for (let i = 0; i < 60; i++) {
          game.decorations.insects.push({
            x: Math.random() * game.worldW,
            y: Math.random() * game.worldH,
            vx: (Math.random() - 0.5) * 20,
            vy: (Math.random() - 0.5) * 20,
            col: Math.random() < 0.5 ? "#ffd166" : "#ffffff",
          });
        }
      }

      /* Initialize canvas / UI */
      function init() {
        const rect = canvas.getBoundingClientRect();
        game.onResize(rect.width, rect.height);
        player.x = game.worldW * 0.5;
        player.y = game.worldH * 0.7;
        clampPlayer();
        setupJoystick();
        setupSkillButtons();
        updateSkillButtons();
        new ResizeObserver(resizeCanvas).observe(canvas);
        resizeCanvas();
        game.reset();
        setTimeout(() => {
          FarcadeSafe.ready();
        }, 250);
      }

      /* Utility: ensure frame element sizing before init */
      function boot() {
        const fc = document.querySelector(".frame");
        const rect = fc.getBoundingClientRect();
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        resizeCanvas();
        init();
      }
      window.addEventListener("load", () => {
        const frame = document.querySelector(".frame");
        const observer = new ResizeObserver(() => {
          const r = frame.getBoundingClientRect();
          canvas.style.width = r.width + "px";
          canvas.style.height = r.height + "px";
          resizeCanvas();
        });
        observer.observe(frame);
        setTimeout(boot, 60);
      });

      /* Helper for updating xp bar DOM and skill coolers */
      (function uiLoop() {
        const bar = $("#xpbar");
        if (bar) bar.style.width = `${Math.min(100, (game.xp / game.xpToNext) * 100)}%`;
        // update cooler overlays even if not cooling (keeps visuals synced)
        for (let i = 0; i < 3; i++) {
          const btn = $(`#skill${i}`);
          const key = game.skillSlots[i];
          const coolDiv = btn?.querySelector(".cooler");
          if (!btn || !coolDiv) continue;
          if (!key) {
            coolDiv.style.background = "transparent";
            continue;
          }
          const cd = game.skillCooldowns[i] || 0;
          const total = ALL_SKILLS[key].cooldown || 4;
          const pct = Math.max(0, Math.min(1, cd / total));
          coolDiv.style.background = `conic-gradient(rgba(0,0,0,0.55) ${pct * 360}deg, transparent 0deg)`;
        }
        requestAnimationFrame(uiLoop);
      })();

      /* Hook skill use via keyboard 1-3 */
      window.addEventListener("keydown", (e) => {
        if (e.key === "1") useSkill(0);
        if (e.key === "2") useSkill(1);
        if (e.key === "3") useSkill(2);
      });

      /* Safe clamp on resize and initial layout */
      window.addEventListener("resize", () => {
        resizeCanvas();
      });

      /* Exported reset for play_again */
      function resetAll() {
        document.getElementById("lvlup")?.remove();
        game.reset();
      }

      /* Ensure first frame */
      resizeCanvas();
      render();
    </script>
  </body>
</html>
