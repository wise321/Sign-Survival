<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Top-down Survival â€” Arcade</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      :root {
        --bg: #0f1724;
        --accent: #ff8c2f;
        --accent2: #ff6b00;
        --hud: #ffffffcc;
        --muted: #ffffff66;
      }
      html, body {
        height: 100%;
        margin: 0;
        background: #071226;
        -webkit-tap-highlight-color: transparent;
      }
      * { box-sizing: border-box; -webkit-user-select: none; user-select: none; touch-action: none; }
      .wrap { width: 100%; max-width: 400px; margin: 14px auto; position: relative; }
      .frame { position: relative; width: 100%; padding-top: 177.7778%; overflow: hidden; border-radius: 12px; background: #000; }
      canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; display: block; image-rendering: pixelated; }

      .touch-layer { position: absolute; inset: 0; pointer-events: none; }
      .joystick, .skills { position: absolute; pointer-events: auto; }
      .joystick { left: 12px; bottom: 12px; width: 140px; height: 140px; }
      .skills { right: 12px; bottom: 12px; display: flex; flex-direction: column; gap: 8px; width: 140px; align-items: flex-end; }

      /* Skill buttons: inner fill = ACTIVE TIME REMAINING, outer ring = COOLDOWN */
      .skill-btn {
        width: 56px; height: 56px; border-radius: 14px;
        background: linear-gradient(180deg, #ffb255 0%, #ff7a1e 100%);
        box-shadow: 0 8px 14px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.08);
        display: grid; place-items: center; color: white; font-weight: 800; font-size: 16px;
        border: 0; position: relative; overflow: hidden; isolation: isolate;
      }
      .skill-btn::before {
        content: ""; position: absolute; inset: 0; border-radius: 14px;
        background: radial-gradient(90% 70% at 50% 0%, rgba(255,255,255,.35) 0%, rgba(255,255,255,.02) 70%);
        mix-blend-mode: screen; pointer-events: none;
      }
      .skill-btn .label { position: relative; z-index: 3; letter-spacing: .5px; }

      /* Active duration fill (top-down) */
      .skill-btn .cooler {
        position: absolute; inset: 0; border-radius: 14px; pointer-events: none; overflow: hidden; z-index: 1;
      }
      .skill-btn .cooler::after {
        content: "";
        position: absolute; left: 0; right: 0; top: 0;
        height: calc((1 - var(--active, 0)) * 100%); /* 1 -> full, 0 -> empty */
        background: linear-gradient(180deg, rgba(48,237,255,.28), rgba(28,167,255,.18));
        transition: height 100ms linear;
      }

      /* Cooldown ring */
      .skill-btn .ring {
        position: absolute; inset: -4px; border-radius: 50%; z-index: 2; pointer-events: none;
        background: conic-gradient(rgba(255,255,255,.92) calc(var(--cool,0) * 360deg), rgba(255,255,255,.15) 0);
        -webkit-mask: radial-gradient(farthest-side, transparent calc(50% - 5px), #000 calc(50% - 5px));
                mask: radial-gradient(farthest-side, transparent calc(50% - 5px), #000 calc(50% - 5px));
        opacity: .85; transition: background 100ms linear, opacity 120ms ease;
      }
      .skill-btn.ready { box-shadow: 0 0 18px rgba(255,158,43,.45), 0 8px 14px rgba(0,0,0,.45); }
      .skill-btn[disabled] { opacity: .45; pointer-events: none; }

      .overlay { position: absolute; inset: 0; background: rgba(2, 6, 23, 0.6); display: flex; align-items: center; justify-content: center; pointer-events: auto; }
      .choices { display: flex; gap: 12px; padding: 12px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); border-radius: 12px; border: 1px solid rgba(255,255,255,0.04); }
      .choice { width: 88px; height: 88px; min-width: 88px; min-height: 88px; background: #0f1724; border-radius: 10px; color: var(--hud); font-size: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; border: 2px solid rgba(255,255,255,0.04); cursor: pointer; }
      .choice:active { transform: scale(0.98); }

      .xpbar-wrap { position: absolute; left: 10%; right: 10%; bottom: 8px; height: 12px; background: rgba(255,255,255,0.06); border-radius: 8px; overflow: hidden; }
      .xpbar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); width: 0%; }

      .wavebar-wrap { position: absolute; top: 6px; left: 0; right: 0; pointer-events: none; z-index: 5; padding-left: 120px; padding-right: 16px; }
      .wavebar { position: relative; margin: 0 auto; width: 82%; max-width: 360px; height: 18px; background: rgba(255,255,255,.08); border-radius: 10px; overflow: hidden; border: 1px solid rgba(255,255,255,.08); }
      .wavebar-fill { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: linear-gradient(90deg, #35d0de, #1ca7ff); transition: width 120ms linear; }
      .wavebar-text { position: absolute; inset: 0; display: grid; place-items: center; color: var(--hud); font: 11px system-ui, sans-serif; text-shadow: 0 1px 0 rgba(0,0,0,.35); }

      @media (max-width: 340px) {
        .joystick { width: 120px; height: 120px; }
        .skills { width: 120px; }
        .skill-btn { width: 52px; height: 52px; }
        .choice { width: 76px; height: 76px; min-width: 76px; min-height: 76px; }
        .wavebar-wrap { padding-left: 100px; }
        .wavebar { width: 84%; max-width: 300px; }
      }
    </style>
  </head>
  <body>
    <div class="wrap" id="gameWrap">
      <div class="frame">
        <canvas id="c"></canvas>

        <div class="wavebar-wrap">
          <div class="wavebar">
            <div class="wavebar-fill" id="waveFill"></div>
            <div class="wavebar-text" id="waveText">Wave 1/100  Enemies 0/30</div>
          </div>
        </div>

        <div class="touch-layer" id="touchLayer">
          <div class="joystick" id="joystick"></div>
          <div class="skills" id="skills">
            <button class="skill-btn" id="skill0" aria-label="skill1" style="background: linear-gradient(180deg, #ffb255, #ff7a1e)">
              <div class="cooler"></div><div class="ring"></div><span class="label">A</span>
            </button>
            <button class="skill-btn" id="skill1" aria-label="skill2" style="background: linear-gradient(180deg, #7c5cff, #4f3bd6)">
              <div class="cooler"></div><div class="ring"></div><span class="label">B</span>
            </button>
            <button class="skill-btn" id="skill2" aria-label="skill3" style="background: linear-gradient(180deg, #35d0de, #1ca7ff)">
              <div class="cooler"></div><div class="ring"></div><span class="label">C</span>
            </button>
          </div>
        </div>

        <div class="xpbar-wrap"><div class="xpbar" id="xpbar"></div></div>
      </div>
    </div>

    <script>
      /* Safe Farcade SDK wrapper */
      const FarcadeSafe = (function () {
        const has = !!(window.FarcadeSDK && window.FarcadeSDK.singlePlayer);
        return {
          ready() { try { if (has) window.FarcadeSDK.singlePlayer.actions.ready(); } catch (e) {} },
          gameOver(obj) { try { if (has) window.FarcadeSDK.singlePlayer.actions.gameOver(obj); } catch (e) {} },
          haptic() { try { if (has) window.FarcadeSDK.singlePlayer.actions.hapticFeedback(); } catch (e) {} },
          on(event, cb) { try { if (window.FarcadeSDK && window.FarcadeSDK.on) window.FarcadeSDK.on(event, cb); } catch (e) {} },
        };
      })();

      const $ = (s, root = document) => root.querySelector(s);
      const canvas = $("#c");
      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = false;
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let SAFE_MARGIN = 24;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        DPR = Math.max(1, window.devicePixelRatio || 1);
        if (rect.width < 2 || rect.height < 2) return;
        canvas.width = Math.round(rect.width * DPR);
        canvas.height = Math.round(rect.height * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        SAFE_MARGIN = Math.max(24, Math.min(rect.width, rect.height) * 0.03);
        game.onResize(rect.width, rect.height);
      }

      /* Optional custom enemy images (enemy1.jpg, enemy2.jpg, enemy3.jpg) with black chroma key removal */
      const CUSTOM_SPRITE_CANVAS = {};
      function loadChromaImage(src, key=[0,0,0], tol=40) {
        return new Promise((resolve) => {
          const img = new Image(); img.crossOrigin = "anonymous";
          img.onload = () => {
            const oc = document.createElement("canvas");
            oc.width = img.width; oc.height = img.height;
            const ox = oc.getContext("2d", { willReadFrequently: true });
            ox.drawImage(img, 0, 0);
            try {
              const data = ox.getImageData(0, 0, oc.width, oc.height);
              const t2 = tol*tol;
              for (let i = 0; i < data.data.length; i += 4) {
                const r = data.data[i], g = data.data[i+1], b = data.data[i+2];
                const dr=r-key[0], dg=g-key[1], db=b-key[2];
                if (dr*dr + dg*dg + db*db <= t2 || (r < 8 && g < 8 && b < 8)) data.data[i+3] = 0;
              }
              ox.putImageData(data, 0, 0);
            } catch (e) {}
            resolve(oc);
          };
          img.onerror = () => resolve(null);
          img.src = src;
        });
      }
      async function loadOptionalEnemyImages() {
        for (const n of ["enemy1","enemy2","enemy3"]) {
          const c = await loadChromaImage(n + ".jpg");
          if (c) CUSTOM_SPRITE_CANVAS[n] = c;
        }
      }

      /* Pixel fallback sprites */
      const SPRITES = {
        enemy1: [
          [null, null, "#16321a", "#16321a", null],
          [null, "#16321a", "#8bd35f", "#8bd35f", "#16321a"],
          ["#16321a", "#8bd35f", "#35d0de", "#8bd35f", "#16321a"],
          [null, "#16321a", "#8bd35f", "#8bd35f", "#16321a"],
          [null, null, "#16321a", "#16321a", null],
        ],
        enemy2: [
          [null, "#003b2f", "#003b2f", "#003b2f", null],
          ["#003b2f", "#35d0de", "#35d0de", "#35d0de", "#003b2f"],
          ["#003b2f", "#35d0de", "#7ff3e9", "#35d0de", "#003b2f"],
          [null, "#003b2f", "#35d0de", "#35d0de", null],
        ],
        enemy3: [
          [null, "#1b1020", "#af7fbf", "#1b1020", null],
          ["#1b1020", "#af7fbf", "#ff9ab0", "#af7fbf", "#1b1020"],
          [null, "#1b1020", "#af7fbf", "#1b1020", null],
        ],
      };
      function normalizeSprites() {
        Object.keys(SPRITES).forEach((k) => {
          const s = SPRITES[k];
          const w = Math.max(...s.map((r) => r.length));
          for (let r = 0; r < s.length; r++) for (let c = 0; c < w; c++) if (typeof s[r][c] === "undefined") s[r][c] = null;
        });
      }
      normalizeSprites();

      function drawPixelSprite(sprite, cx, cy, desiredW, outline) {
        const h = sprite.length, w = sprite[0].length;
        const scale = desiredW / w;
        const sx = Math.floor(-desiredW / 2), sy = Math.floor(-(h * scale) / 2);
        for (let r = 0; r < h; r++) for (let c = 0; c < w; c++) {
          const col = sprite[r][c]; if (!col) continue;
          ctx.fillStyle = col;
          ctx.fillRect(cx + sx + c * scale, cy + sy + r * scale, Math.ceil(scale), Math.ceil(scale));
          if (outline) { ctx.strokeStyle = "rgba(0,0,0,0.25)"; ctx.strokeRect(cx + sx + c * scale, cy + sy + r * scale, Math.ceil(scale), Math.ceil(scale)); }
        }
      }

      /* Game state */
      const game = {
        worldW: 1920,
        worldH: 1080,
        viewW: 300,
        viewH: 533,
        running: false,
        enemies: [],
        bullets: [],
        pickups: [],
        explosions: [],
        fxParticles: [],
        damageTexts: [],
        world: { trees: [], flowers: [], houses: [], roads: [] },

        score: 0,
        level: 1,
        xp: 0,
        xpToNext: 20,

        hp: 50,
        maxHp: 50,

        // Waves
        wave: 1,
        maxWaves: 100,
        waveTotal: 0,
        waveKills: 0,
        waveSpawned: 0,
        waveAliveCap: 0,
        spawnTimer: 0,
        spawnCadence: 1.6,

        // Skills
        skillSlots: [null, null, null],
        skillCooldowns: [0, 0, 0],
        skillLevels: {},
        skillActiveTimers: [0, 0, 0],
        skillActiveTotals: [1, 1, 1],

        paused: false,
        muted: false,
        joystickVec: { x: 0, y: 0 },
        lastHitTime: 0,
        playLoopReq: null,
        shootTimer: 0,
        baseFireInterval: 0.3,
        timeElapsed: 0,
        cameraX: 0, cameraY: 0,
        lastAimAngle: -Math.PI / 2,

        onResize(w, h) {
          this.viewW = w; this.viewH = h;
          this.cameraX = clamp(this.cameraX, 0, Math.max(0, this.worldW - this.viewW));
          this.cameraY = clamp(this.cameraY, 0, Math.max(0, this.worldH - this.viewH));
          clampPlayer();
        },
        reset() {
          this.enemies = []; this.bullets = []; this.pickups = [];
          this.explosions = []; this.fxParticles = []; this.damageTexts = [];
          this.score = 0; this.level = 1; this.xp = 0; this.xpToNext = 20;
          this.hp = this.maxHp = 50; this.timeElapsed = 0;
          this.wave = 1; this.waveTotal = 0; this.waveKills = 0; this.waveSpawned = 0;
          this.waveAliveCap = 0; this.spawnTimer = 0; this.spawnCadence = 1.6;
          this.skillSlots = [null, null, null];
          this.skillCooldowns = [0, 0, 0];
          this.skillLevels = {};
          this.skillActiveTimers = [0,0,0]; this.skillActiveTotals = [1,1,1];
          this.paused = false; this.running = true;
          this.lastAimAngle = -Math.PI / 2;

          player.x = this.worldW * 0.5; player.y = this.worldH * 0.7; player.dir = { x: 0, y: -1 };
          player.invuln = 0; player.shootingAnim = 0; this.shootTimer = 0;
          player._hasteT = 0; player._hasteMult = 1;

          buildWorld();
          startWave(this.wave);
        },
      };

      const player = {
        x: 960, y: 756, r: 18, speed: 160, dir: { x: 0, y: -1 }, color: "#ffa93a",
        invuln: 0, _regen: 0, _xpBoost: 0, _dmg: 0, _multishot: 0,
        shootingAnim: 0, walkAnim: 0,
        _hasteT: 0, _hasteMult: 1,
      };

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
      function clampPlayer() {
        player.x = clamp(player.x, SAFE_MARGIN + player.r, game.worldW - SAFE_MARGIN - player.r);
        player.y = clamp(player.y, SAFE_MARGIN + player.r, game.worldH - SAFE_MARGIN - player.r);
      }
      function normalize(x, y) { const m = Math.hypot(x, y) || 1; return { x: x / m, y: y / m }; }
      function circleHit(ax, ay, ar, bx, by, br) { return (ax - bx) * (ax - bx) + (ay - by) * (ay - by) <= (ar + br) * (ar + br); }

      /* Input */
      const keys = {};
      window.addEventListener("keydown", (e) => { keys[e.key.toLowerCase()] = true; });
      window.addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });

      const joystickEl = $("#joystick");
      let joyState = { active: false, origin: { x: 0, y: 0 }, pos: { x: 0, y: 0 } };
      function setupJoystick() {
        const jcan = document.createElement("canvas");
        const jctx = jcan.getContext("2d");
        joystickEl.appendChild(jcan);
        function sizeCanvas() { jcan.width = joystickEl.clientWidth * DPR; jcan.height = joystickEl.clientHeight * DPR; jcan.style.width = "100%"; jcan.style.height = "100%"; }
        sizeCanvas(); new ResizeObserver(sizeCanvas).observe(joystickEl);
        function drawJoy() {
          const w = jcan.width, h = jcan.height, cx = w / 2, cy = h / 2;
          jctx.clearRect(0, 0, w, h); jctx.save(); jctx.scale(DPR, DPR);
          jctx.fillStyle = "rgba(255,255,255,0.04)"; jctx.beginPath();
          jctx.arc(cx / DPR, cy / DPR, Math.min(jcan.clientWidth, jcan.clientHeight) / 2.2, 0, Math.PI * 2); jctx.fill();
          jctx.fillStyle = "rgba(255,255,255,0.08)";
          const px = cx / DPR + (joyState.pos.x - joyState.origin.x), py = cy / DPR + (joyState.pos.y - joyState.origin.y);
          jctx.beginPath(); jctx.arc(px, py, Math.min(jcan.clientWidth, jcan.clientHeight) / 6, 0, Math.PI * 2); jctx.fill();
          jctx.restore(); requestAnimationFrame(drawJoy);
        }
        drawJoy();
        function toLocal(e, el) { const r = el.getBoundingClientRect(); if (e.touches) e = e.touches[0]; return { x: e.clientX - r.left, y: e.clientY - r.top }; }
        function start(e) { e.preventDefault(); joyState.active = true; const p = toLocal(e, joystickEl); joyState.origin = { x: p.x, y: p.y }; joyState.pos = { x: p.x, y: p.y }; }
        function move(e) {
          if (!joyState.active) return; const p = toLocal(e, joystickEl); joyState.pos = { x: p.x, y: p.y };
          const dx = joyState.pos.x - joyState.origin.x, dy = joyState.pos.y - joyState.origin.y;
          const max = joystickEl.clientWidth * 0.35, mag = Math.hypot(dx, dy), nx = mag > 1 ? dx / Math.max(1, mag) : 0, ny = mag > 1 ? dy / Math.max(1, mag) : 0;
          const len = Math.min(max, mag) / max; game.joystickVec.x = nx * len; game.joystickVec.y = ny * len;
        }
        function end() { joyState.active = false; game.joystickVec.x = 0; game.joystickVec.y = 0; }
        joystickEl.addEventListener("touchstart", start, { passive: false });
        joystickEl.addEventListener("touchmove", move, { passive: false });
        joystickEl.addEventListener("touchend", end);
        joystickEl.addEventListener("mousedown", (e) => { start(e); window.addEventListener("mousemove", move); window.addEventListener("mouseup", () => { end(); window.removeEventListener("mousemove", move); }); });
      }

      /* Enemy stats */
      function enemyBaseStats(type) {
        switch (type) {
          case "enemy1": return { baseHp: 24, baseSpeed: 70 };
          case "enemy2": return { baseHp: 32, baseSpeed: 50 };
          case "enemy3": return { baseHp: 18, baseSpeed: 110 };
          default: return { baseHp: 24, baseSpeed: 70 };
        }
      }

      /* Group spawning with size-based HP buffs */
      function spawnEnemyGroup(count) {
        const types = ["enemy1", "enemy2", "enemy3"];
        const side = Math.floor(Math.random() * 4);
        const pad = SAFE_MARGIN;
        let ax, ay;
        if (side === 0) { ax = -60; ay = pad + Math.random() * (game.worldH - pad * 2); }
        else if (side === 1) { ax = game.worldW + 60; ay = pad + Math.random() * (game.worldH - pad * 2); }
        else if (side === 2) { ax = pad + Math.random() * (game.worldW - pad * 2); ay = -60; }
        else { ax = pad + Math.random() * (game.worldW - pad * 2); ay = game.worldH + 60; }

        const spread = 120;
        const waveFactorHp = 1 + (game.wave - 1) * 0.18;
        const speedFactor = 1 + (game.wave - 1) * 0.02;

        for (let n = 0; n < count; n++) {
          if (game.waveSpawned >= game.waveTotal) return;
          const t = types[Math.floor(Math.random() * types.length)];
          const base = enemyBaseStats(t);

          const size = 12 + Math.random() * 20; // some bigger = more HP
          const sizeBuff = 1 + Math.max(0, (size - 12) / 20) * 0.7; // up to +70% HP
          const hp = Math.round((base.baseHp + Math.random() * 8) * waveFactorHp * sizeBuff);
          const speed = (base.baseSpeed + Math.random() * 20) * speedFactor;

          const a = Math.random() * Math.PI * 2;
          const r = (Math.random() ** 0.7) * spread;
          const x = ax + Math.cos(a) * r;
          const y = ay + Math.sin(a) * r;

          game.enemies.push({ x, y, type: t, speed, hp, maxHp: hp, r: size, spriteKey: t });
          game.waveSpawned++;
        }
      }

      /* Skills */
      const ALL_SKILLS = {
        explosion_active: {
          name: "Explosion",
          desc: "Fiery blast with smoke.",
          type: "active",
          cooldown: 8,
          maxLevel: 15,
          duration(level) { return 0.3; }, // short bar just to show you pressed it
          activate(level) {
            const base = 100 + 20 * Math.max(0, level - 1);
            const mult = 1 + (player._dmg || 0);
            const dmg = base * mult;
            radialDamage(player.x, player.y, 92, dmg); // affects all inside radius
            createExplosion(player.x, player.y, 92, 0.22);
            spawnExplosionFX(player.x, player.y);
            FarcadeSafe.haptic();
          },
        },
        shield_active: {
          name: "Shield",
          desc: "Temporary invulnerability.",
          type: "active",
          cooldown: 12,
          maxLevel: 15,
          duration(level) { return 5 + 0.5 * Math.max(0, level - 1); },
          activate(level) {
            const dur = 5 + 0.5 * Math.max(0, level - 1);
            player.invuln = Math.max(player.invuln || 0, dur);
            FarcadeSafe.haptic();
          },
        },
        quickshot_active: {
          name: "Rapid Fire",
          desc: "Attacks much faster for 7s.",
          type: "active",
          cooldown: 15,
          maxLevel: 15,
          duration(level) { return 7; },
          activate(level) {
            const mult = 1.8 + 0.1 * Math.max(0, level - 1);
            player._hasteMult = Math.max(player._hasteMult || 1, mult);
            player._hasteT = Math.max(player._hasteT || 0, 7);
            FarcadeSafe.haptic();
          },
        },
        // passives
        hp_plus_passive: { name: "+Max HP", desc: "Increase max HP by 20", type: "passive", apply() { game.maxHp += 20; game.hp += 20; } },
        regen_passive: { name: "Regen", desc: "Gain +1 HP/sec", type: "passive", apply() { player._regen = (player._regen || 0) + 1; } },
        xp_plus_passive: { name: "XP Boost", desc: "+25% XP gain", type: "passive", apply() { player._xpBoost = (player._xpBoost || 0) + 0.25; } },
        damage_passive: { name: "Damage+", desc: "Active skills +25% damage", type: "passive", apply() { player._dmg = (player._dmg || 0) + 0.25; } },
        multishot_passive: { name: "MultiShot", desc: "Shoot more targets", type: "passive", apply() { player._multishot = (player._multishot || 0) + 1; } },
      };
      const ACTIVE_KEYS = ["explosion_active", "shield_active", "quickshot_active"];
      function isSkillMaxed(k) { const s = ALL_SKILLS[k]; const lv = game.skillLevels[k] || 0; return s && s.type === "active" && lv >= (s.maxLevel || 15); }
      function equippedSlotOf(k) { for (let i = 0; i < 3; i++) if (game.skillSlots[i] === k) return i; return -1; }
      function hasEmptySkillSlot() { return game.skillSlots.some((s) => s === null); }

      function chooseSkillOptions() {
        const opts = [];
        const empty = hasEmptySkillSlot();
        for (const k of ACTIVE_KEYS) { const eq = equippedSlotOf(k) >= 0; if (eq && !isSkillMaxed(k)) opts.push(k); }
        if (empty) for (const k of ACTIVE_KEYS) { if (equippedSlotOf(k) < 0 && !isSkillMaxed(k)) opts.push(k); }
        for (const k of Object.keys(ALL_SKILLS)) if (ALL_SKILLS[k].type === "passive") opts.push(k);
        const unique = [...new Set(opts)], pick = [];
        while (pick.length < 3 && unique.length) pick.push(unique.splice(Math.floor(Math.random() * unique.length), 1)[0]);
        return pick;
      }

      function showLevelUpOverlay() {
        const wrap = document.createElement("div"); wrap.className = "overlay"; wrap.id = "lvlup";
        const choicesWrap = document.createElement("div"); choicesWrap.className = "choices";
        const opts = chooseSkillOptions();
        opts.forEach((k) => {
          const info = ALL_SKILLS[k]; const c = document.createElement("div"); c.className = "choice"; c.tabIndex = 0;
          let subtitle = info.type === "active" ? "Active" : "Passive";
          if (info.type === "active") { const lv = game.skillLevels[k] || 0; const max = info.maxLevel || 15; subtitle += ` ${lv > 0 ? "(Lv " + lv + ")" : "(New)"}`; if (lv >= max) subtitle += " (MAX)"; }
          c.innerHTML = `<div style="font-weight:700">${info.name}</div><small style="opacity:.8">${subtitle}</small>`;
          c.addEventListener("click", () => {
            if (info.type === "passive") info.apply && info.apply();
            else {
              const max = info.maxLevel || 15; const cur = game.skillLevels[k] || 0;
              if (cur >= max) {} else if (cur > 0) game.skillLevels[k] = Math.min(max, cur + 1);
              else { const slot = game.skillSlots.findIndex((s) => s === null); if (slot >= 0) { game.skillSlots[slot] = k; game.skillCooldowns[slot] = 0; game.skillLevels[k] = 1; updateSkillButtons(); } }
            }
            document.getElementById("lvlup")?.remove(); game.paused = false;
          });
          choicesWrap.appendChild(c);
        });
        wrap.appendChild(choicesWrap); document.querySelector(".frame").appendChild(wrap);
      }

      function updateSkillButtons() {
        for (let i = 0; i < 3; i++) {
          const btn = document.getElementById(`skill${i}`);
          const label = btn.querySelector(".label");
          const cool = btn.querySelector(".cooler");
          const ring = btn.querySelector(".ring");
          const key = game.skillSlots[i];

          if (!key) {
            label.textContent = "+"; btn.style.opacity = 0.6; btn.setAttribute("disabled","true");
            cool.style.setProperty("--active","0"); ring.style.setProperty("--cool","0"); btn.classList.remove("ready");
          } else {
            const nm = ALL_SKILLS[key].name.slice(0,2).toUpperCase(); label.textContent = nm; btn.style.opacity = 1; btn.removeAttribute("disabled");
            const cd = game.skillCooldowns[i] || 0; const totalCd = ALL_SKILLS[key].cooldown || 4;
            const coolPct = 1 - Math.max(0, Math.min(1, cd / totalCd));
            ring.style.setProperty("--cool", String(coolPct));
            const at = game.skillActiveTimers[i] || 0, atTot = game.skillActiveTotals[i] || 1;
            const activePct = Math.max(0, Math.min(1, at / atTot));
            cool.style.setProperty("--active", String(activePct));
            if (cd <= 0) btn.classList.add("ready"); else btn.classList.remove("ready");
          }
        }
      }
      function useSkill(i) {
        const key = game.skillSlots[i]; if (!key) return;
        const s = ALL_SKILLS[key]; if (!s) return; if (game.skillCooldowns[i] > 0) return;
        const lv = game.skillLevels[key] || 1;
        s.activate(lv);
        const dur = typeof s.duration === "function" ? s.duration(lv) : 0;
        game.skillActiveTimers[i] = dur > 0 ? dur : 0;
        game.skillActiveTotals[i] = Math.max(1, dur || 1);
        game.skillCooldowns[i] = s.cooldown || 4;
        updateSkillButtons();
      }

      /* Combat helpers */
      function radialDamage(cx, cy, radius, dmg) {
        for (let i = game.enemies.length - 1; i >= 0; i--) {
          const e = game.enemies[i];
          if (circleHit(cx, cy, radius, e.x, e.y, e.r)) {
            e.hp -= dmg;
            game.damageTexts.push({ x: e.x, y: e.y - e.r - 6, val: Math.round(dmg), ttl: 0.7, vy: -18 });
          }
        }
      }
      function createExplosion(x, y, r, life = 0.22) { game.explosions.push({ x, y, r, life, ttl: life }); }
      function spawnExplosionFX(x, y) {
        for (let i = 0; i < 2; i++) game.fxParticles.push({ type: "ring", x, y, r: 14 + i * 12, vr: 360, alpha: 0.7, va: -1.4, ttl: 0.35 });
        for (let i = 0; i < 26; i++) { const a = Math.random() * Math.PI * 2, sp = 140 + Math.random() * 160; game.fxParticles.push({ type: "spark", x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: 1.5 + Math.random() * 2.5, ttl: 0.45 + Math.random() * 0.25, hue: 18 + Math.random() * 20 }); }
        for (let i = 0; i < 14; i++) { const a = Math.random() * Math.PI * 2, sp = 30 + Math.random() * 60; game.fxParticles.push({ type: "smoke", x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: 10 + Math.random() * 14, alpha: 0.35, ttl: 0.8 + Math.random() * 0.4 }); }
      }

      function fireBulletTowardsTarget(x, y, targetX, targetY, dmg = 12) {
        const nx = targetX - x, ny = targetY - y, m = Math.hypot(nx, ny) || 1, speed = 460;
        game.bullets.push({ x, y, vx: (nx / m) * speed, vy: (ny / m) * speed, r: 4, dmg, ttl: 2.6 });
        player.shootingAnim = 0.22;
        game.lastAimAngle = Math.atan2(ny, nx);
        FarcadeSafe.haptic();
      }

      /* Waves (+10 per wave, balanced caps) */
      function waveSize(w) { return 30 + 10 * (w - 1); }
      function waveAliveCap(w) { return Math.min(42, 14 + Math.floor(w * 1.2)); }

      function startWave(w) {
        game.wave = w; game.waveTotal = waveSize(w); game.waveKills = 0; game.waveSpawned = 0;
        game.waveAliveCap = waveAliveCap(w);
        game.spawnCadence = Math.max(0.9, 2.0 - w * 0.05); // time between groups
        game.spawnTimer = 0.4;
        updateWaveBar();
      }
      function nextWave() {
        if (game.wave >= game.maxWaves) {
          game.running = false; FarcadeSafe.haptic();
          FarcadeSafe.gameOver({ score: Math.floor(game.score), victory: true, waves: game.wave });
          showVictoryOverlay(); return;
        }
        startWave(game.wave + 1);
      }
      function showVictoryOverlay() {
        const wrap = document.createElement("div"); wrap.className = "overlay";
        wrap.innerHTML = `<div class="choices" style="flex-direction:column;align-items:center;padding:20px">
          <div style="color:var(--hud);font-weight:800;font-size:18px">You cleared Wave ${game.maxWaves}!</div>
          <div style="color:var(--hud);opacity:.8;margin-top:6px">Score: ${Math.floor(game.score)}</div>
        </div>`;
        document.querySelector(".frame").appendChild(wrap);
      }

      function updateWaveBar() {
        const fill = $("#waveFill"), text = $("#waveText");
        const pct = Math.min(1, game.waveKills / Math.max(1, game.waveTotal));
        if (fill) fill.style.width = `${pct * 100}%`;
        if (text) text.textContent = `Wave ${game.wave}/${game.maxWaves}  Enemies ${game.waveKills}/${game.waveTotal}`;
      }

      /* World build: more trees, more houses, long roads, flowers */
      function buildWorld() {
        const W = game.worldW, H = game.worldH;
        game.world.trees = [];
        game.world.houses = [];
        game.world.flowers = [];
        game.world.roads = [];

        // Roads go beyond edges so they extend across map
        game.world.roads.push({
          pts: [
            { x: -120, y: H + 80 },
            { x: W * 0.22, y: H * 0.72 },
            { x: W * 0.45, y: H * 0.52 },
            { x: W * 0.66, y: H * 0.34 },
            { x: W + 120, y: -80 },
          ],
          width: 46
        });
        game.world.roads.push({
          pts: [
            { x: W * 0.40, y: H * 0.60 },
            { x: W * 0.32, y: H * 0.40 },
            { x: W * 0.20, y: H * 0.22 },
            { x: -120,  y: H * 0.12 }
          ],
          width: 38
        });

        // Houses
        const houseSpots = [
          { x: W * 0.27, y: H * 0.67, s: 1.15 },
          { x: W * 0.56, y: H * 0.36, s: 1.2 },
          { x: W * 0.40, y: H * 0.52, s: 1.05 },
          { x: W * 0.18, y: H * 0.25, s: 1.1 },
        ];
        game.world.houses.push(...houseSpots);

        // Many bigger trees
        for (let i = 0; i < 380; i++) {
          game.world.trees.push({
            x: Math.random() * W,
            y: Math.random() * H,
            s: 1.15 + Math.random() * 0.55
          });
        }

        // Flowers
        for (let i = 0; i < 1000; i++) {
          game.world.flowers.push({
            x: Math.random() * W,
            y: Math.random() * H,
            c: Math.random() < 0.33 ? "#ffd166" : (Math.random() < 0.5 ? "#ff7ac9" : "#ffffff")
          });
        }
      }

      /* Main loop */
      let lastFrame = performance.now();
      function loop(ts) {
        game.playLoopReq = requestAnimationFrame(loop);
        const now = ts; const dt = Math.min(0.06, (now - lastFrame) / 1000); lastFrame = now;
        if (!game.running) { render(); return; }
        if (game.paused) { render(); return; }

        game.timeElapsed += dt;

        // input/movement
        const kbX = (keys["arrowright"] || keys["d"] ? 1 : 0) - (keys["arrowleft"] || keys["a"] ? 1 : 0);
        const kbY = (keys["arrowdown"] || keys["s"] ? 1 : 0) - (keys["arrowup"] || keys["w"] ? 1 : 0);
        let ix = game.joystickVec.x || kbX, iy = game.joystickVec.y || kbY;
        const moving = ix !== 0 || iy !== 0;
        if (moving) { const n = normalize(ix, iy); player.x += n.x * player.speed * dt; player.y += n.y * player.speed * dt; player.dir = { x: n.x, y: n.y }; player.walkAnim = (player.walkAnim || 0) + dt * 14; }
        else player.walkAnim = Math.max(0, (player.walkAnim || 0) - dt * 8);
        clampPlayer();

        // camera snapped to integer to remove top jitter
        game.cameraX = Math.round(clamp(player.x - game.viewW / 2, 0, Math.max(0, game.worldW - game.viewW)));
        game.cameraY = Math.round(clamp(player.y - game.viewH / 2, 0, Math.max(0, game.worldH - game.viewH)));

        // regen
        if (player._regen) game.hp = Math.min(game.maxHp, game.hp + player._regen * dt);

        // Rapid Fire buff timer
        if (player._hasteT > 0) {
          player._hasteT = Math.max(0, player._hasteT - dt);
          if (player._hasteT === 0) player._hasteMult = 1;
        }

        // Active-duration timers for buttons
        for (let i = 0; i < 3; i++) if (game.skillActiveTimers[i] > 0) game.skillActiveTimers[i] = Math.max(0, game.skillActiveTimers[i] - dt);

        // auto-fire
        const autoShootRange = 200;
        const fireInterval = game.baseFireInterval / (player._hasteMult || 1);
        game.shootTimer -= dt;
        if (game.shootTimer <= 0) {
          const enemiesInRange = game.enemies.map((e) => ({ e, d: Math.hypot(e.x - player.x, e.y - player.y) })).filter((o) => o.d <= autoShootRange).sort((a, b) => a.d - b.d);
          if (enemiesInRange.length > 0) {
            game.shootTimer = fireInterval;
            const shots = 1 + (player._multishot || 0);
            const targets = enemiesInRange.slice(0, shots);
            const baseDmg = Math.round(12 * (1 + (player._dmg || 0)));
            for (const t of targets) {
              const dir = normalize(t.e.x - player.x, t.e.y - player.y);
              const bx = player.x + dir.x * (player.r + 10), by = player.y + dir.y * (player.r + 10);
              fireBulletTowardsTarget(bx, by, t.e.x, t.e.y, baseDmg);
            }
          }
        }

        // grouped spawns
        game.spawnTimer -= dt;
        if (game.spawnTimer <= 0 && game.enemies.length < game.waveAliveCap && game.waveSpawned < game.waveTotal) {
          const remaining = game.waveTotal - game.waveSpawned;
          const aliveSlots = Math.max(0, game.waveAliveCap - game.enemies.length);
          const base = Math.round(clamp(6 + game.wave * 0.9, 6, 20 + game.wave * 0.25));
          let groupSize = Math.min(remaining, Math.max(4, Math.min(aliveSlots, base + Math.floor(Math.random() * 3) - 1)));
          spawnEnemyGroup(groupSize);
          game.spawnTimer = game.spawnCadence + 0.4 * Math.random();
        }

        // bullets
        for (let i = game.bullets.length - 1; i >= 0; i--) {
          const b = game.bullets[i];
          b.x += b.vx * dt; b.y += b.vy * dt; b.ttl -= dt;
          for (let j = game.enemies.length - 1; j >= 0; j--) {
            const e = game.enemies[j];
            if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r)) {
              e.hp -= b.dmg;
              game.damageTexts.push({ x: e.x, y: e.y - e.r - 6, val: b.dmg, ttl: 0.7, vy: -18 });
              b.ttl = -1; createExplosion(b.x, b.y, 10, 0.08); break;
            }
          }
          if (b.ttl <= 0 || b.x < -100 || b.x > game.worldW + 100 || b.y < -100 || b.y > game.worldH + 100) game.bullets.splice(i, 1);
        }

        // enemies
        for (let i = game.enemies.length - 1; i >= 0; i--) {
          const e = game.enemies[i];
          const dx = player.x - e.x, dy = player.y - e.y, mag = Math.hypot(dx, dy) || 1;
          e.x += (dx / mag) * e.speed * dt; e.y += (dy / mag) * e.speed * dt;

          const contactDmg = 1 + (game.wave - 1) * 0.2;
          if (circleHit(e.x, e.y, e.r, player.x, player.y, player.r + (player.invuln ? 4 : 0))) {
            if (!player.invuln && now / 1000 - game.lastHitTime > 0.5) {
              game.hp -= contactDmg; game.lastHitTime = now / 1000; FarcadeSafe.haptic();
            }
          }

          if (e.hp <= 0) {
            game.score += Math.floor(5 + Math.random() * 8 + game.wave * 2);
            let xpGain = 4 + Math.floor(Math.random() * 6) + Math.floor(game.wave * 0.6);
            if (player._xpBoost) xpGain = Math.floor(xpGain * (1 + player._xpBoost));
            game.pickups.push({ x: e.x, y: e.y, amt: xpGain, ttl: 12, seed: Math.random() });
            game.enemies.splice(i, 1);
            game.waveKills++; updateWaveBar(); FarcadeSafe.haptic();
            if (game.waveKills >= game.waveTotal) nextWave();
          }
        }

        for (let i = game.explosions.length - 1; i >= 0; i--) { const ex = game.explosions[i]; ex.ttl -= dt; if (ex.ttl <= 0) game.explosions.splice(i, 1); }
        for (let i = game.fxParticles.length - 1; i >= 0; i--) {
          const p = game.fxParticles[i]; p.ttl -= dt;
          if (p.type === "ring") { p.r += p.vr * dt; p.alpha += p.va * dt; }
          else if (p.type === "spark") { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.96; p.vy *= 0.96; }
          else if (p.type === "smoke") { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.95; p.vy *= 0.95; p.alpha *= 0.985; p.r *= 1.012; }
          if (p.ttl <= 0 || p.alpha <= 0) game.fxParticles.splice(i, 1);
        }

        // pickups
        for (let i = game.pickups.length - 1; i >= 0; i--) {
          const p = game.pickups[i]; p.ttl -= dt;
          const dx = player.x - p.x, dy = player.y - p.y, d = Math.hypot(dx, dy), magnetRange = 120;
          if (d < magnetRange) { const pull = (1 - d / magnetRange) * 320; p.x += (dx / (d || 1)) * pull * dt; p.y += (dy / (d || 1)) * pull * dt; }
          if (circleHit(p.x, p.y, 8, player.x, player.y, player.r)) { game.xp += p.amt; FarcadeSafe.haptic(); game.pickups.splice(i, 1); continue; }
          if (p.ttl <= 0) game.pickups.splice(i, 1);
        }

        // cooldowns
        for (let i = 0; i < 3; i++) if (game.skillCooldowns[i] > 0) game.skillCooldowns[i] = Math.max(0, game.skillCooldowns[i] - dt);

        // damage text
        for (let i = game.damageTexts.length - 1; i >= 0; i--) {
          const t = game.damageTexts[i]; t.ttl -= dt; t.y += t.vy * dt; t.vy += 40 * dt; if (t.ttl <= 0) game.damageTexts.splice(i, 1);
        }

        if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);
        game.score += dt * 0.3;
        updateSkillButtons();
        if (game.xp >= game.xpToNext) { game.xp -= game.xpToNext; game.level += 1; game.xpToNext = Math.floor(game.xpToNext * 1.35 + game.level * 5); game.paused = true; FarcadeSafe.haptic(); showLevelUpOverlay(); }

        if (game.hp <= 0) { game.running = false; FarcadeSafe.haptic(); FarcadeSafe.gameOver({ score: Math.floor(game.score), waves: game.wave }); }

        render();
      }

      /* Rendering */
      function render() {
        const vw = game.viewW, vh = game.viewH;
        const camX = game.cameraX, camY = game.cameraY;

        drawLandscape(camX, camY, vw, vh);

        // explosions + FX
        for (const ex of game.explosions) {
          const sx = ex.x - camX, sy = ex.y - camY; const t = Math.max(0, ex.ttl / ex.life);
          ctx.fillStyle = `rgba(255,120,80,${0.12 + 0.28 * t})`; ctx.beginPath();
          ctx.arc(sx, sy, ex.r * (1 + (1 - t) * 0.8), 0, Math.PI * 2); ctx.fill();
        }
        for (const p of game.fxParticles) {
          const sx = p.x - camX, sy = p.y - camY;
          if (p.type === "ring") { ctx.strokeStyle = `rgba(255,200,120,${Math.max(0, p.alpha)})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI * 2); ctx.stroke(); }
          else if (p.type === "spark") { ctx.fillStyle = `hsl(${p.hue}, 90%, 60%)`; ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI * 2); ctx.fill(); }
          else if (p.type === "smoke") { ctx.fillStyle = `rgba(80,80,80,${p.alpha})`; ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI * 2); ctx.fill(); }
        }

        // bullets
        for (const b of game.bullets) {
          const sx = b.x - camX, sy = b.y - camY; if (sx < -20 || sx > vw + 20 || sy < -20 || sy > vh + 20) continue;
          ctx.save(); ctx.translate(sx, sy);
          ctx.fillStyle = "rgba(255,240,180,0.98)"; ctx.beginPath(); ctx.ellipse(0, 0, b.r, b.r * 0.8, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        }

        // pickups
        for (const p of game.pickups) {
          const sx = p.x - camX, sy = p.y - camY; if (sx < -40 || sx > vw + 40 || sy < -40 || sy > vh + 40) continue;
          const pulse = 0.8 + 0.2 * Math.sin((game.timeElapsed * 3) + (p.seed || 0)); const outer = 10 + 4 * pulse;
          ctx.save(); ctx.globalCompositeOperation = "lighter"; ctx.shadowBlur = 10 * pulse; ctx.shadowColor = "rgba(80,200,255,0.7)";
          const grad = ctx.createRadialGradient(sx, sy, 2, sx, sy, outer);
          grad.addColorStop(0, "rgba(140,230,255,0.7)"); grad.addColorStop(0.4, "rgba(60,190,255,0.4)"); grad.addColorStop(1, "rgba(30,120,180,0.08)");
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(sx, sy, outer, 0, Math.PI * 2); ctx.fill(); ctx.restore();
          ctx.fillStyle = "#7ff3e9"; ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI * 2); ctx.fill();
        }

        // enemies (custom images if present)
        for (const e of game.enemies) {
          const sx = e.x - camX, sy = e.y - camY;
          const img = CUSTOM_SPRITE_CANVAS[e.spriteKey];
          if (img) {
            const desiredW = Math.max(24, e.r * 2.2);
            const aspect = img.width / img.height || 1;
            const w = desiredW, h = desiredW / aspect;
            ctx.drawImage(img, Math.floor(sx - w/2), Math.floor(sy - h/2), Math.floor(w), Math.floor(h));
          } else {
            const sprite = SPRITES[e.spriteKey] || SPRITES.enemy1;
            drawPixelSprite(sprite, sx, sy, Math.max(18, e.r * 1.8), true);
          }
          ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(sx - e.r, sy - e.r - 8, e.r * 2, 4);
          ctx.fillStyle = "rgba(255,255,255,0.85)"; ctx.fillRect(sx - e.r, sy - e.r - 8, Math.max(0, (e.hp / e.maxHp)) * e.r * 2, 4);
        }

        // player
        const psx = player.x - camX, psy = player.y - camY;
        drawOrangePlayer(psx, psy);
        if (player.invuln > 0) {
          const alpha = 0.35 + 0.15 * Math.sin(game.timeElapsed * 8), r = player.r * (1.7 + 0.05 * Math.sin(game.timeElapsed * 6));
          ctx.save(); ctx.globalCompositeOperation = "lighter";
          const g = ctx.createRadialGradient(psx, psy, r * 0.6, psx, psy, r);
          g.addColorStop(0, `rgba(80,200,255,${alpha})`); g.addColorStop(1, `rgba(28,167,255,${alpha * 0.5})`);
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(psx, psy, r, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        }
        drawPlayerBow(psx, psy);

        // damage text
        ctx.textAlign = "center"; ctx.font = "12px system-ui";
        for (const t of game.damageTexts) { const sx = t.x - camX, sy = t.y - camY; ctx.fillStyle = "rgba(255,240,220,0.98)"; ctx.fillText(t.val, sx, sy); }

        // HUD
        ctx.fillStyle = "rgba(255,255,255,0.92)"; ctx.font = "14px system-ui, sans-serif"; ctx.textAlign = "left";
        const pad = SAFE_MARGIN; ctx.fillText(`Score: ${Math.floor(game.score)}`, pad, pad + 12);
        ctx.fillStyle = "rgba(255,255,255,0.65)"; ctx.fillText(`Level: ${game.level}`, pad, pad + 32);
        const hpW = 120; ctx.fillStyle = "rgba(255,255,255,0.08)"; ctx.fillRect(pad, pad + 42, hpW, 10);
        ctx.fillStyle = "#ff6b6b"; ctx.fillRect(pad, pad + 42, hpW * (Math.max(0, game.hp) / game.maxHp), 10);
        ctx.strokeStyle = "rgba(255,255,255,0.06)"; ctx.strokeRect(pad, pad + 42, hpW, 10);
        ctx.fillStyle = "rgba(255,255,255,0.6)"; ctx.font = "11px system-ui, sans-serif"; ctx.fillText(`HP: ${Math.floor(Math.max(0, game.hp))}/${game.maxHp}`, pad + hpW + 8, pad + 51);

        if (player._hasteT > 0) {
          const secs = Math.ceil(player._hasteT);
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.fillText(`Rapid Fire ${secs}s`, vw - 120, pad + 14);
        }
      }

      /* Landscape: bright grass, long roads, trees, houses, flowers (pixel style) */
      function drawLandscape(camX, camY, vw, vh) {
        // grass base
        ctx.fillStyle = "#7ccb53"; ctx.fillRect(0, 0, vw, vh);

        // grass texture
        const tile = 16;
        for (let gx = Math.floor(camX / tile) * tile; gx < camX + vw + tile; gx += tile) {
          for (let gy = Math.floor(camY / tile) * tile; gy < camY + vh + tile; gy += tile) {
            const sx = gx - camX, sy = gy - camY;
            ctx.fillStyle = "#6bb946"; ctx.fillRect(sx + 10, sy + 6, 2, 2);
            ctx.fillStyle = "#8edc64"; ctx.fillRect(sx + 6, sy + 3, 2, 2);
          }
        }

        // roads
        ctx.save();
        ctx.translate(-camX, -camY);
        for (const road of game.world.roads) {
          const p = new Path2D();
          for (let i = 0; i < road.pts.length; i++) {
            const pt = road.pts[i];
            if (i === 0) p.moveTo(pt.x, pt.y);
            else {
              const prev = road.pts[i - 1];
              const cx = (prev.x + pt.x) / 2, cy = (prev.y + pt.y) / 2;
              p.quadraticCurveTo(prev.x, prev.y, cx, cy);
            }
          }
          ctx.lineWidth = road.width;
          ctx.lineCap = "round";
          ctx.strokeStyle = "#e9d584"; ctx.stroke(p);
          ctx.save();
          ctx.globalCompositeOperation = "multiply";
          ctx.strokeStyle = "rgba(0,0,0,0.12)";
          ctx.stroke(p);
          ctx.restore();
        }
        ctx.restore();

        // houses
        for (const h of game.world.houses) drawHouse(h.x - camX, h.y - camY, h.s);

        // trees
        for (const t of game.world.trees) drawPixelTree(t.x - camX, t.y - camY, t.s);

        // flowers
        for (let i = 0; i < game.world.flowers.length; i++) {
          const f = game.world.flowers[i];
          const sx = f.x - camX, sy = f.y - camY;
          if (sx < -8 || sx > vw + 8 || sy < -8 || sy > vh + 8) continue;
          ctx.fillStyle = f.c; ctx.fillRect(Math.round(sx), Math.round(sy), 2, 2);
        }
      }

      function drawPixelTree(x, y, s=1) {
        ctx.save(); ctx.translate(Math.round(x), Math.round(y)); ctx.scale(s, s);
        ctx.fillStyle = "rgba(0,0,0,0.20)"; ctx.beginPath(); ctx.ellipse(0, 12, 12, 5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#6b3f1d"; ctx.fillRect(-2, -2, 4, 14);
        ctx.fillStyle = "#4fa93f"; ctx.beginPath(); ctx.arc(0, -8, 14, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#2f7b2c"; ctx.beginPath(); ctx.arc(-7, -10, 9, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#7cd86a"; ctx.beginPath(); ctx.arc(7, -10, 9, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function drawHouse(x, y, s=1) {
        ctx.save(); ctx.translate(Math.round(x), Math.round(y)); ctx.scale(s, s);
        ctx.fillStyle = "rgba(0,0,0,0.25)"; ctx.fillRect(-20, 18, 44, 6);
        ctx.fillStyle = "#f2e4b3"; ctx.fillRect(-18, 0, 36, 22);
        ctx.fillStyle = "#5e3a1f"; ctx.fillRect(-4, 8, 8, 14);
        ctx.fillStyle = "#cc3024"; ctx.beginPath(); ctx.moveTo(-22, 0); ctx.lineTo(0, -14); ctx.lineTo(22, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = "#e0523e"; ctx.beginPath(); ctx.moveTo(-18, 0); ctx.lineTo(0, -10); ctx.lineTo(18, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = "#d4b36c"; ctx.fillRect(10, 8, 8, 6);
        ctx.restore();
      }

      /* Player visuals */
      function drawOrangePlayer(cx, cy) {
        const r = player.r * 1.3; ctx.save(); ctx.translate(cx, cy);
        ctx.fillStyle = "rgba(0,0,0,0.25)"; ctx.beginPath(); ctx.ellipse(0, r * 0.9, r * 0.9, r * 0.35, 0, 0, Math.PI * 2); ctx.fill();
        const grad = ctx.createRadialGradient(-r * 0.25, -r * 0.5, r * 0.2, 0, 0, r * 1.05);
        grad.addColorStop(0, "#ffd68a"); grad.addColorStop(0.35, "#ffb24f"); grad.addColorStop(1, "#ff7a1e");
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "#4e3a1f"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-2, -r + 6); ctx.lineTo(4, -r - 6); ctx.stroke();
        const dir = normalize(player.dir.x || 0, player.dir.y || -1); const ang = Math.atan2(dir.y, dir.x);
        ctx.save(); ctx.translate(4, -r - 6); ctx.rotate(ang * 0.15 - 0.4);
        const lg = ctx.createLinearGradient(0, 0, 26, 0); lg.addColorStop(0, "#0f7a2f"); lg.addColorStop(1, "#33c165");
        ctx.fillStyle = lg; ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(18, -8, 26, 0); ctx.quadraticCurveTo(18, 8, 0, 0); ctx.fill(); ctx.restore();
        ctx.save(); ctx.translate(0, -r * 0.1); ctx.rotate(ang * 0.05);
        const lensW = r * 0.75, lensH = r * 0.34, pad = 3;
        roundedRect(-lensW - pad, -lensH, lensW, lensH * 2, 9, "#ffffff");
        roundedRect(pad, -lensH, lensW, lensH * 2, 9, "#ffffff");
        ctx.fillStyle = "#ffffff"; ctx.fillRect(-pad, -3, pad * 2, 6);
        ctx.globalAlpha = 0.9; roundedRect(-lensW - pad + 3, -lensH + 3, lensW - 6, lensH * 2 - 6, 7, "#ff6a00");
        roundedRect(pad + 3, -lensH + 3, lensW - 6, lensH * 2 - 6, 7, "#ff6a00"); ctx.globalAlpha = 1; ctx.restore(); ctx.restore();
        function roundedRect(x, y, w, h, r, fill) { ctx.fillStyle = fill; ctx.beginPath();
          ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); ctx.fill();
        }
      }

      function drawPlayerBow(cx, cy) {
        const ang = game.lastAimAngle;
        const dir = { x: Math.cos(ang), y: Math.sin(ang) };
        const perp = { x: -dir.y, y: dir.x };
        const ox = perp.x * 10 + dir.x * 6, oy = perp.y * 10 + dir.y * 6 + 6;

        ctx.save(); ctx.translate(cx + ox, cy + oy); ctx.rotate(ang);
        const pullNorm = Math.min(1, player.shootingAnim / 0.22), recoilTilt = -0.06 * pullNorm; ctx.rotate(recoilTilt);
        ctx.strokeStyle = "#3a2a1f"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(6, 0, 10, -Math.PI / 2, Math.PI / 2); ctx.stroke();
        ctx.strokeStyle = "#cfcfcf"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-4 - 2 * pullNorm, -9); ctx.lineTo(-4 - 2 * pullNorm, 9); ctx.stroke();
        ctx.fillStyle = "#ffb24f"; ctx.fillRect(-10, -3, 6, 6);
        const pull = 10 * pullNorm; ctx.strokeStyle = "#6b3b1f"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-12 - pull, 0); ctx.lineTo(12, 0); ctx.stroke();
        ctx.fillStyle = "#111827"; ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(8, -3); ctx.lineTo(8, 3); ctx.closePath(); ctx.fill();
        ctx.restore();
      }

      /* UI loop */
      (function uiLoop() {
        const bar = $("#xpbar"); if (bar) bar.style.width = `${Math.min(100, (game.xp / game.xpToNext) * 100)}%`;
        updateWaveBar();
        updateSkillButtons();
        requestAnimationFrame(uiLoop);
      })();

      function setupSkillButtons() {
        for (let i = 0; i < 3; i++) {
          const el = document.getElementById(`skill${i}`);
          el.addEventListener("touchstart", (e) => { e.preventDefault(); useSkill(i); }, { passive: false });
          el.addEventListener("mousedown", (e) => { e.preventDefault(); useSkill(i); });
        }
      }
      window.addEventListener("keydown", (e) => { if (e.key === "1") useSkill(0); if (e.key === "2") useSkill(1); if (e.key === "3") useSkill(2); });

      FarcadeSafe.on && FarcadeSafe.on("play_again", () => { document.getElementById("lvlup")?.remove(); document.querySelectorAll(".overlay").forEach((o) => o.remove()); game.reset(); });
      FarcadeSafe.on && FarcadeSafe.on("toggle_mute", ({ isMuted }) => { game.muted = !!isMuted; });

      /* Robust boot to avoid zero-size canvas black screen */
      function init() {
        const rect = canvas.getBoundingClientRect();
        canvas.style.width = rect.width + "px"; canvas.style.height = rect.height + "px";
        resizeCanvas();
        setupJoystick(); setupSkillButtons(); updateSkillButtons();
        game.reset();
        loadOptionalEnemyImages();
        if (!game.playLoopReq) game.playLoopReq = requestAnimationFrame(loop);
        setTimeout(() => FarcadeSafe.ready(), 250);
      }
      function boot() {
        const frame = document.querySelector(".frame");
        function tryStart() {
          const r = frame.getBoundingClientRect();
          if (r.width < 10 || r.height < 10) { requestAnimationFrame(tryStart); return; }
          canvas.style.width = r.width + "px"; canvas.style.height = r.height + "px";
          resizeCanvas(); init();
          const observer = new ResizeObserver(() => {
            const rr = frame.getBoundingClientRect();
            canvas.style.width = rr.width + "px"; canvas.style.height = rr.height + "px";
            resizeCanvas();
          });
          observer.observe(frame);
        }
        tryStart();
      }
      window.addEventListener("load", boot);
      window.addEventListener("resize", () => resizeCanvas());
    </script>
  </body>
</html>
